/**
 * @author jonobr1 / http://jonobr1.com
 */
(function() {

  var root = this;
  var _ = Two.Utils;
  var max = Math.max, min = Math.min;
  var projection = new Two.Vector();
  var vector = new Two.Vector();
  var TWO_PI = Math.PI * 2;

  var Trail = Two.Trail = function(points, curved) {

    var length = points.length;
    this.points = points;

    this.lengths = [];
    this.lengths.total = 0;

    var vertices = _.map(_.range(length * 2), function(i) {
      var k = i;
      if (i >= length) {
        k = length - (i % length) - 1;
      }
      var dest = points[k];
      return new Two.Anchor().copy(dest);
    }, this);

    Two.Path.call(this, vertices, true, curved);

    this.forwards = _.map(_.range(0, length), function(i) {
      return this.vertices[i];
    }, this);

    this.backwards = _.map(_.range(length, length * 2).reverse(), function(i) {
      return this.vertices[i];
    }, this);

    this.noStroke().fill = 'black';

  };

  _.extend(Trail, {

  });

  _.extend(Trail.prototype, Two.Path.prototype, {

    strokeWeight: 1,
    weightAlgorithm: function(v) {
      return 1 - v;
    },

    update: function() {

      var length = 0, last = this.points.length - 1;
      var angle = 0, perimeter = 0;

      this.lengths.length = 0;

      updateLength.call(this);

      for (var i = 0; i < this.points.length; i++) {

        var dest = this.points[i];
        var a, b, f, pct;

        b = this.backwards[i];
        f = this.forwards[i];

        if (i > 0) {

          prev = getPointAt.call(this, perimeter / this.lengths.total - 0.1);

          a = Math.atan2(prev.y - dest.y, prev.x - dest.x) + Math.PI / 2;


        } else {

          prev = getPointAt.call(this, perimeter / this.lengths.total + 0.1);

          a = Math.atan2(dest.y - prev.y, dest.x - prev.x) + Math.PI / 2;
          angle = a;

        }

        pct = this.weightAlgorithm(i / last);

        var delta = a - angle;
        var isNormal = delta < 0;

        projection.x = pct * this.strokeWeight * Math.cos(a);
        projection.y = pct * this.strokeWeight * Math.sin(a);

        f.copy(dest)[isNormal ? 'add' : 'sub'](projection);
        b.copy(dest)[isNormal ? 'sub' : 'add'](projection);

        angle = a;

      }

      return this;

    }

  });

  Two.Path.MakeObservable(Trail.prototype);

  function updateLength() {

    var b, a;

    this.lengths.total = 0;

    for (var i = 0; i < this.points.length; i++) {

      var a = this.points[i];

      if (i <= 0) {
        b = a;
        this.lengths[i] = 0;
        continue;
      }

      this.lengths[i] = Two.Path.Utils.getCurveLength(a, b);
      this.lengths[i] = Two.Utils.toFixed(this.lengths[i]);
      this.lengths.total += this.lengths[i];

      b = a;

    }

  }

  function getPointAt(t, obj) {

    var ia, ib, result;
    var x, x1, x2, x3, x4, y, y1, y2, y3, y4, left, right;
    var target = this.lengths.total * Math.min(Math.max(t, 0), 1);
    var length = this.points.length;
    var last = length - 1;

    var a = null;
    var b = null;

    for (var i = 0, l = this.lengths.length, sum = 0; i < l; i++) {

      if (sum + this.lengths[i] >= target) {

        ia = i;
        ib = Math.min(Math.max(i - 1, 0), last);

        a = this.points[ia];
        b = this.points[ib];
        target -= sum;

        if (this.lengths[i] !== 0) {
          t = target / this.lengths[i];
        } else {
          t = 0;
        }

        break;

      }

      sum += this.lengths[i];

    }

    if (_.isNull(a) || _.isNull(b)) {
      return null;
    }

    if (!a) {
      return b;
    } else if (!b) {
      return a;
    }

    right = b.controls && b.controls.right;
    left = a.controls && a.controls.left;

    x1 = b.x;
    y1 = b.y;
    x2 = (right || b).x;
    y2 = (right || b).y;
    x3 = (left || a).x;
    y3 = (left || a).y;
    x4 = a.x;
    y4 = a.y;

    if (right && b.relative) {
      x2 += b.x;
      y2 += b.y;
    }

    if (left && a.relative) {
      x3 += a.x;
      y3 += a.y;
    }

    x = Two.Utils.getComponentOnCubicBezier(t, x1, x2, x3, x4);
    y = Two.Utils.getComponentOnCubicBezier(t, y1, y2, y3, y4);

    // Higher order points for control calculation.
    var t1x = Two.Utils.lerp(x1, x2, t);
    var t1y = Two.Utils.lerp(y1, y2, t);
    var t2x = Two.Utils.lerp(x2, x3, t);
    var t2y = Two.Utils.lerp(y2, y3, t);
    var t3x = Two.Utils.lerp(x3, x4, t);
    var t3y = Two.Utils.lerp(y3, y4, t);

    // Calculate the returned points control points.
    var brx = Two.Utils.lerp(t1x, t2x, t);
    var bry = Two.Utils.lerp(t1y, t2y, t);
    var alx = Two.Utils.lerp(t2x, t3x, t);
    var aly = Two.Utils.lerp(t2y, t3y, t);

    if (_.isObject(obj)) {

      obj.x = x;
      obj.y = y;

      if (!_.isObject(obj.controls)) {
        Two.Anchor.AppendCurveProperties(obj);
      }

      obj.controls.left.x = brx;
      obj.controls.left.y = bry;
      obj.controls.right.x = alx;
      obj.controls.right.y = aly;

      if (!_.isBoolean(obj.relative) || obj.relative) {
        obj.controls.left.x -= x;
        obj.controls.left.y -= y;
        obj.controls.right.x -= x;
        obj.controls.right.y -= y;
      }

      obj.t = t;

      return obj;

    }

    result = new Two.Anchor(
      x, y, brx - x, bry - y, alx - x, aly - y,
      this._curved ? Two.Commands.curve : Two.Commands.line
    );

    result.t = t;

    return result;

  }

})();
